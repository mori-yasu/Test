Chapter 5: Surface normals and multiple objects.
First, let’s get ourselves a surface normal so we can shade. This is a vector that is perpendicular
to the surface, and by convention, points out. One design decision is whether these normals
(again by convention) are unit length. That is convenient for shading so I will say yes, but I won’t
enforce that in the code. This could allow subtle bugs, so be aware this is personal preference
as are most design decisions like that. For a sphere, the normal is in the direction of the hitpoint
minus the center:

On the earth, this implies that the vector from the earth’s center to you points straight up. Let’s
throw that into the code now, and shade it. We don’t have any lights or anything yet, so let’s just
visualize the normals with a color map. A common trick used for visualizing normals (because
it’s easy and somewhat intuitive to assume N is a unit length vector– so each component is
between -1 and 1) is to map each component to the interval from 0 to 1, and then map x/y/z to
r/g/b. For the normal we need the hit point, not just whether we hit or not. Let’s assume the
closest hit point (smallest t). These changes in the code let us compute and visualize N:
And that yields this picture:

Now, how about several spheres? While it is tempting to have an array of spheres, a very clean
solution is the make an “abstract class” for anything a ray might hit and make both a sphere and
a list of spheres just something you can hit. What that class should be called is something of a
quandary-- calling it an “object” would be good if not for “object oriented” programming.
“Surface” is often used, with the weakness being maybe we will want volumes. “Hitable”
emphasizes the member function that unites them. I don’t love any of these but I will go with
“hitable”.
This hitable abstract class will have a hit function that takes in a ray. Most ray tracers have
found it convenient to add a valid interval for hits tmin to tmax, so the hit only “counts” if tmin < t
< tmax. For the initial rays this is positive t, but as we will see, it can help some details in the
code to have an interval tmin to tmax. One design question is whether to do things like compute
the normal if we hit something; we might end up hitting something closer as we do our search,
and we will only need the normal of the closest thing. I will go with the simple solution and
compute a bundle of stuff I will store in some structure. I know we’ll want motion blur at some
point, so I’ll add a time input variable. Here’s the abstract class:

And here’s the sphere (note that I eliminated a bunch of redundant 2’s that cancel each other
out):

And a list of objects:

And the new main:

This yields a picture that is really just a visualization of where the spheres are along with their
surface normal. This is often a great way to look at your model for flaws and characteristics.

-------------------------------------------------------------------------------------------------------------------
第5章：表面の法線と複数のオブジェクト。
まず、シェーディングできるように、表面の法線を取得しましょう。これは垂直なベクトルです
表面に、そして慣例により、指摘しています。設計上の決定事項の1つは、これらの法線が
（これも慣例により）単位の長さです。これはシェーディングに便利なので、「はい」と言いますが、
コードでそれを強制します。これにより微妙なバグが発生する可能性があるため、これは個人的な好みであることに注意
そのようなほとんどの設計決定もそうです。球の場合、法線はヒットポイントの方向にあります
中心を引いたもの：

地球上では、これは地球の中心からあなたへのベクトルが真上を指すことを意味します。しましょう
それを今すぐコードに入れて、シェーディングします。まだライトも何もありませんので、
カラーマップで法線を視覚化します。法線の視覚化に使用される一般的なトリック（
Nが単位長さのベクトルであると仮定するのは簡単で、やや直感的です。したがって、各コンポーネントは
-1と1の間）は、各コンポーネントを0から1の間隔にマッピングし、x / y / zを
r / g / b。通常の場合、ヒットするかどうかだけでなく、ヒットポイントが必要です。仮定しましょう
最も近いヒットポイント（最小t）。コードのこれらの変更により、Nを計算して視覚化できます。
そして、それはこの絵をもたらします：

さて、いくつかの球体はどうですか？球体の配列を持つことは魅力的ですが、非常にきれいな
解決策は、光線が当たる可能性のあるすべての「抽象クラス」を作成し、球と
ヒットできる球体のリスト。そのクラスを呼び出す必要があるのは
「オブジェクト指向」プログラミングでない場合は、「オブジェクト」と呼ぶのが良いでしょう。
「表面」がよく使用されますが、その弱点はボリュームが必要になることです。 「Hitable」
それらを結合するメンバー関数を強調します。これらはどれも好きではありませんが、一緒に行きます
「hitable」。
このヒット可能な抽象クラスには、光線を取り込むヒット関数があります。ほとんどのレイトレーサーには
ヒットtminからtmaxまでの有効な間隔を追加すると便利です。したがって、ヒットはtmin <tの場合にのみ「カウント」されます
<tmax。最初の光線の場合、これは正のtですが、これから見るように、
間隔tminからtmaxを持つコード。設計上の問題の1つは、計算などを行うか
何かをヒットした場合の通常;検索を行うと、より近いものにぶつかる可能性があります。
そして、最も近いものの法線のみが必要になります。私は簡単な解決策と一緒に行きます
何らかの構造に格納するもののバンドルを計算します。モーションブラーが必要になることはわかっています
ポイントなので、時間入力変数を追加します。抽象クラスは次のとおりです。

そして、ここに球体があります（互いにキャンセルする冗長な2の束を削除したことに注意してください）
でる）：

そしてオブジェクトのリスト：

そして、新しいメイン：

これにより、実際に球がどこにあるのかを視覚化しただけの画像が得られます
表面法線。これは、多くの場合、モデルの欠陥や特性を調べるのに最適な方法です。